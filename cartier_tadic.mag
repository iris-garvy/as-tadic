load "build_matrix.mag";
load "projectiveline.mag";

compute_genus := function(d,p);
    return Integers()!((d+1-2) * (p-1)/2);
end function;


//Note that this find_mu function is only accurate for p>d
find_mu := function(i,d,p);
    answer := p+1;
    while (answer-1)*d/p gt i do
        answer := answer - 1;
    end while;
    return answer;
end function;

truncate_poly := function(f,cutoff,R)
    T := R.1;
    return &+[ Coefficient(f, i) * T^i : i in [0..cutoff] ];
end function;


apply_T := function(f : n := 1)
    y := Parent(f).1;
    for i in [1..n] do
        f := Evaluate(f, y+1) - f;
    end for;
    return f;
end function;

apply_Tpoly := function(f, Tpolynomial)
    R:= Parent(f);
    d := Degree(Tpolynomial);
    polynomial_list := [(R!0)^^d];
    for i in [0..d] do
        if Coefficient(Tpolynomial,i) ne 0 then
            Append(~polynomial_list, Coefficient(Tpolynomial,i)*apply_T(f: n:=i));
        end if;
    end for;
    return &+polynomial_list;
end function;

find_rcoeff := function(p) 
    Fp := FiniteField(p);
    A<T> := PolynomialRing(Fp);
    B<y> := PolynomialRing(A);
    r_list := [];
    i := 1;
    for i in [1..p-1] do
        r_coeff := T^i; //note that this is a terrible implementation. I just didnt want to think about how to do it smart.
        transformed_w0 := apply_Tpoly(-y^(p-1),r_coeff);

        while transformed_w0 ne -y^((p-1)-i) do 
            difference := -y^((p-1)-i) - transformed_w0;
            r_coeff +:= T^(p-1-Degree(difference));
            transformed_w0 := apply_Tpoly(-y^(p-1),r_coeff);
        end while;
        r_coeff := r_coeff/(T^Degree(TrailingTerm(r_coeff)));
        Append(~r_list,r_coeff);

    end for;
     return r_list;
end function;


construct_tadic := function (f,p)
    Fp := FiniteField(p);
    Ab_unred<T> := PolynomialRing(Fp);
    Rp<x> := PolynomialRing(Ab_unred);

    d := Degree(f);
    matrix_size := Floor((p-1)*d/p);

    f := &+[ Coefficient(f, i) * x^i : i in [0..d+1] ];
    
    //find alpha to the first level
    alpha := 1 + T*f + T^2 * (f - f^2);

    //calculate alpha inverse
    alpha_inverse := 1;

    for i in [1..p-1] do
        alpha_inverse := alpha_inverse + (1 - alpha*alpha_inverse);
    end for;
    
    //write out cartier matrix
    cartier_coefficients := Coefficients(alpha_inverse);

    nM := [[Ab_unred!0^^matrix_size]^^matrix_size];

    for i in [1..matrix_size] do
        for j in [1..matrix_size] do
            if p*i - j lt 0 or p*i - j + 1 gt #cartier_coefficients then
                nM[i][j] := 0;
            else
                nM[i][j] := truncate_poly(cartier_coefficients[p*i-j+1], p-1, Ab_unred); 
                
            end if;
        end for;
    end for; 

    nM := Matrix(Ab_unred, matrix_size, matrix_size, nM);
    return nM;
end function;


construct_schmidt := function(f,p)
    d := Degree(f);
    Fp := FiniteField(p);
    ZZp:= FiniteField(p,2);
    matrix_size := compute_genus(d,p);

    AH_precision := p*matrix_size;
    ps_precision := p*matrix_size;

    Q := Rationals();

    // Calculate Artin Hasse coefficients up to AH_precision
    AH_coefficients := [Q.1, Q.1];

    for n in [2..AH_precision] do
        un := 0;

        for i in [0..n] do
            index := n - p^i + 1;
            if index gt 0 then
                un := un + AH_coefficients[index];
            else
                break;
            end if;
        end for;

        un := un / n;
        AH_coefficients[#AH_coefficients +1] := un;
    end for;

    AH_coefficients := [ZZp ! x : x in AH_coefficients];

    AH<xpi> := Polynomial(AH_coefficients);
    LL<zetaminus1> := PowerSeriesRing(ZZp,5);
    AH := LL ! (AH-1);
    AH := Reverse(AH);

    R<xpi> := PolynomialRing(ZZp);
    Zpi<xpi> := quo<R | xpi^(p-1) + p>;
    Zpi_Fp<w> := PolynomialRing(Fp);
    L<x> := PolynomialRing(Zpi);

    f:= L!f;

    //Get Sum from multiplying G = theta(pi*x^i)theta(pi*j)...
    B := 1;
        for term in Terms(f) do
            B := B * (&+[AH_coefficients[i+1] * (xpi * L!term)^(i): i in [0..ps_precision-1]]);
        end for;
    B_coefficients := Coefficients(B);

    //Create Frobenius?/Cartier-Manin? matrix
    nM := [[L!0^^matrix_size]^^matrix_size];

    for i in [1..matrix_size] do
        for j in [1..matrix_size] do
            if p*i - j lt 0 or p*i-j+1 gt #B_coefficients then
                nM[i][j] := 0;
            else
                nM[i][j] := B_coefficients[p*i-j+1]; 
            end if;
        end for;
    end for; 

    nM := Matrix(nM);
    return(nM);
end function;

//okay lets construct the matrix that converts the R basis into the M_1 Basis
r2m_Matrix := function(d,p)
    matrix_size := Floor((p-1)*d/p);

    Fp := FiniteField(p);
    Ab_unred<T> := PolynomialRing(Fp);


    r_coefficients := find_rcoeff(p);

    mu_index := [];
    for i in [1..matrix_size] do
        Append(~mu_index, find_mu(i,d,p));
    end for;


    e_coefficients := [];
    for i in [1..matrix_size] do
        Append(~e_coefficients, (T^mu_index[i])*r_coefficients[mu_index[i]]);
    end for;

    change_matrix_basis := DiagonalMatrix(Ab_unred, e_coefficients);
    return change_matrix_basis;
end function;


// print(count);
sample_minimal:=function(d,p);
    count:=10000;
    K:=GF(p);
    FF<t>:=FunctionField(K);
    lowerbound:=lower_bound(d,p);
    upperbound:=upper_bound(d,p);

    if (d mod p eq 0) then
	    return "Invalid";
    end if;

    dictionary := [[],[]];
    n :=0;
    while (n lt count) do
        n := n+1;
        f := rand_poly(t,d,p);
        a := anumber(f,d,FF);

        index := Position(dictionary[1], a);
        if index eq 0 then
            Append(~dictionary[1],a);
            Append(~dictionary[2],1);
        else
            dictionary[2][index] +:= 1;
        end if;
            

    end while;

    return dictionary;
end function;


power_shift := function(i,d,p)
    off_set := 1;
    for x_power in [1..i-1] do
        off_set := off_set + p - find_mu(x_power,d,p);
    end for;
    return off_set;
end function;



a_numberT := function(f,p)
    d:=Degree(f);
    matrix_size := Floor((p-1)*d/p);
    Fp := GF(p);
    Ab_unred<T> := PolynomialRing(Fp);
    Rp<x> := PolynomialRing(Ab_unred);
    f := &+[ Coefficient(f, i) * x^i : i in [0..d+1] ];
    g:=compute_genus(d,p);
    k_Cartier := [[Fp!0^^g]^^g];
    r_coefficients := r2m_Matrix(d,p);

    M:= Transpose(construct_tadic(f,p));
    for x_power in [1..matrix_size] do
        x_row := M[x_power]*T^(find_mu(x_power,d,p)-1)*r_coefficients[x_power][x_power];
        for T_power in [0..p-find_mu(x_power,d,p)-1] do
            x_row := x_row * T;
            for x_col in [1..matrix_size] do
                modded_polynomial := truncate_poly(x_row[x_col], p-1, Ab_unred);
                for term in Terms(modded_polynomial) do
                    k_Cartier[power_shift(x_power,d,p)+T_power][Degree(term)+power_shift(x_col,d,p)-find_mu(x_col,d,p)] := Coefficient(term, Degree(term));
                end for;
            end for;
        end for;
    end for;
    return compute_genus(d,p)- Rank(Matrix(Fp,g,g,k_Cartier));
end function;

rand_poly_pos:=function(t,d,p) ;
    K:=GF(p);
    poly := t^(d) ; //issue: what is t
    for i in [1..d-1] do
        if (i mod p ne 0) then
            poly := poly + Random(K)*t^(i);
        end if;
    end for;
    return poly;
end function;


check_method:=function(d,p);
    count:=1000;
    K:=GF(p);
    PF<t>:=PolynomialRing(K);
    FF<x>:=FunctionField(K);
    lowerbound:=lower_bound(d,p);
    upperbound:=upper_bound(d,p);

    if (d mod p eq 0) then
	    return "Invalid";
    end if;

    n :=0;
    mismatches:=0;
    while (n lt count) do
        n := n+1;
        f := rand_poly_pos(t,d,p);
        a_T := a_numberT(PF!f,p);
        f := &+[ Coefficient(f, i) * x^(-i) : i in [0..d+1] ];
        a := anumber(f,d,FF);

        if a_T ne a then
            mismatches := mismatches +1;
        end if;

    end while;

    return mismatches;
end function;

p:=11;
Fp:= GF(p);
R<x>:=PolynomialRing(Fp);
f:= x^28+x^16+x^3;
print(a_numberT(f,11));


//for some reason this only works for d<p. i tried fixing the find_mu but it doesn't change for some reason.
guess_a := function(d,p)
    return compute_genus(d,p) - &+[p-find_mu(i,d,p)-Round(p*i/d): i in [1..Ceiling(d/2)-1] ];
end function;



