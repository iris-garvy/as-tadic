compute_genus := function(d,p);
    return Integers()!((d+1-2) * (p-1)/2);
end function;

find_mu := function(i,d,p);
    answer := p-1;
    while (answer-1)*d/p gt i do
        answer := answer - 1;
    end while;
    return answer;
end function;

truncate_poly := function(f,d,R)
    T := R.1;
    return &+[ Coefficient(f, i) * T^i : i in [0..d] ];
end function;


apply_T := function(f,R)
    y := R.1;
    return Evaluate(f, y+1) - f;
end function;

// since im programming i can just do it iteratively instead of figuring out a general formula


p := 3;

Fp := FiniteField(p);
Ab_unred<T> := PolynomialRing(Fp);
A := FunctionField(Fp);
Rp<x> := PolynomialRing(Ab_unred);

//set polynomial
f := x^8+x^4;
d := Degree(f);
matrix_size := Floor((p-1)*d/p);

//find alpha to the first level
alpha := 1 + T*f + T^2 * (f - f^2);

//calculate alpha inverse
alpha_inverse := 1;

for i in [1..p-1] do
    alpha_inverse := alpha_inverse + (1 - alpha*alpha_inverse);
end for;

//write out cartier matrix
cartier_coefficients := Coefficients(alpha_inverse);

nM := [[A!0^^matrix_size]^^matrix_size];

for i in [1..matrix_size] do
    for j in [1..matrix_size] do
        if p*i - j lt 0 or p*i - j + 1 gt #cartier_coefficients then
            nM[i][j] := 0;
        else
            nM[i][j] := cartier_coefficients[p*i-j+1]; 
        end if;
    end for;
end for; 

nM := Matrix(Ab_unred, matrix_size, matrix_size, nM);

//okay lets construct the matrix that converts the R basis into the M_1 Basis

//I was gonna saw we need to find i(n) but thats gotta just be the genus so we can just use compute genus (for our simple case)
// wait its not the genus im confused :sob:

//the following will be only for p=3 before i figure out how to generalize it more


r_coefficients := [2+2*T, 2];

mu_index := [];
for i in [1..matrix_size] do
    Append(~mu_index, find_mu(i,d,p));
end for;


e_coefficients := [];
for i in [1..matrix_size] do
    Append(~e_coefficients, (T^mu_index[i])*r_coefficients[mu_index[i]]);
end for;


change_matrix_basis := DiagonalMatrix(Ab_unred, e_coefficients);

nM := nM*change_matrix_basis;
nM := Matrix(Ab_unred, Nrows(nM), Ncols(nM), [ truncate_poly(nM[i,j], p-1, Ab_unred) : j in [1..Nrows(nM)], i in [1..Ncols(nM)] ]);
nM := ChangeRing(change_matrix_basis,A)^-1*ChangeRing(nM,A);


for i in [1..Ncols(nM)] do
    for j in [1..Nrows(nM)] do
        if Denominator(nM[i,j]) ne 1 then
            denominator := Denominator(nM[i,j]);
            denominator_inverse := 1;
            for k in [1..p] do
                denominator_inverse := denominator_inverse + (1 - denominator*denominator_inverse);
            end for;
            nM[i,j] := Numerator(nM[i,j])*denominator_inverse;
        end if;
    end for;
end for;

nM := Matrix(Ab_unred, Nrows(nM), Ncols(nM), [ truncate_poly((Ab_unred!nM[i,j]), (p-1)-Degree(TrailingTerm(e_coefficients[i])), Ab_unred) : j in [1..Nrows(nM)], i in [1..Ncols(nM)] ]);
            

